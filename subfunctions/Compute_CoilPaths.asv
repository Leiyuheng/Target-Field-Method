function coilPaths = Compute_CoilPaths(streamFunction, surfaceCurrent, params, direction)
% 将Ψ等值线转换为导线路径点，并按电流实际方向输出路径数据
% coilPaths - 结构体，包含 Positive 与 Negative 路径，均已按电流流动方向排序

%% 参数提取
phi = params.phi;
z   = params.z;
r   = params.a;
num_levels = params.num_levels;

% 选择对应方向的数据
% 根据经验设置contourc的等值线最小幅度阈值 低于该幅度不作为路径 可以减小体积
switch lower(direction)
    case 'x'
        Psi  = streamFunction.Psi_x;
        Jphi = surfaceCurrent.Jphi_x;
        Jz   = surfaceCurrent.Jz_x;
        v = abs_levels(Psi, params.x_contourc_minabs, num_levels);
    case 'y'
        Psi  = streamFunction.Psi_y;
        Jphi = surfaceCurrent.Jphi_y;
        Jz   = surfaceCurrent.Jz_y;
        v = abs_levels(Psi, params.y_contourc_minabs, num_levels);
    case 'z'
        Psi  = streamFunction.Psi_z;
        Jphi = surfaceCurrent.Jphi_z;
        Jz   = surfaceCurrent.Jz_z;
        v = abs_levels(Psi, params.z_contourc_minabs, num_levels);
    otherwise
        error('direction 只能是 x / y / z');
end

%% 提取等值线并转换为三维路径
contourData = contourc(phi, z, Psi, v);
rawPaths = struct('Positive',{{}}, 'Negative',{{}});
idx = 1;
while idx < size(contourData,2)
    level = contourData(1,idx);
    npts  = contourData(2,idx);
    path_phi = contourData(1, idx+1:idx+npts);
    path_z   = contourData(2, idx+1:idx+npts);
    x = r * cos(path_phi);
    y = r * sin(path_phi);
    raw = [x', y', path_z'];
    if level > 0
        rawPaths.Positive{end+1} = raw;
    else
        rawPaths.Negative{end+1} = raw;
    end
    idx = idx + npts + 1;
end

%% 闭合与互补处理
phi_step = abs(phi(2)-phi(1));
close_thr = 1e-3 * r * phi_step;
match_thr = r * phi_step;
procPaths.Positive = ProcessPaths(rawPaths.Positive, close_thr, match_thr);
procPaths.Negative = ProcessPaths(rawPaths.Negative, close_thr, match_thr);

%% 方向校正
% visual_coilpath(procPaths, [], [])
% coilPaths = procPaths;
coilPaths = CorrectPathDirection(procPaths, direction);

disp(['Compute_CoilPaths: ', direction, ' 方向绕线路径提取与校正完成']);
end


%% 内置函数

function corrected = CorrectPathDirection(procPaths, dir)
% 功能：对闭合路径执行方向校正，使电流方向与流函数保持一致

corrected = procPaths;

% 校正路径
for i = 1:length(procPaths.Negative)
    pathN = procPaths.Negative{i};
    pathP = procPaths.Positive{i};

    % 空路径检查
    if isempty(pathN) || isempty(pathP)
        continue;
    end

    switch dir
        case 'x'
            % x梯度线圈反转条件
            if pathN(1,2) > 0
                corrected.Negative{i} = flipud(pathN);
            end
            corrected.Positive{i} = flipud(pathP);
        case 'y'
            % y梯度线圈反转条件
            if pathN(1,1) < 0
                corrected.Negative{i} = flipud(pathN);
            end
            if pathP(1,1) < 0
                corrected.Positive{i} = flipud(pathP);
            end
        case 'z'
            % z梯度线圈反转条件
            corrected.Positive{i} = flipud(pathP);

        otherwise
            error('仅支持方向：x / y / z');
    end
end


end



function v = abs_levels(Z, t, nPerSide)
% 生成满足 |v| >= t 的等值列表（升序）
zmin = min(Z(:)); zmax = max(Z(:));
lo = zmin ;
hi = zmax ;

vneg = []; vpos = [];
if lo < -t
    vneg = linspace(lo, -t, nPerSide+1);
end
if hi >  t
    vpos = linspace(t, hi, nPerSide+1);
end
v = unique([vneg(2:end), vpos(1:end-1)], 'sorted'); % 丢弃掉两个端点
if isempty(v)
    warning('数据范围内不存在 |v| >= t 的可用等值线。');
end

end

function minDistMat = minContourDistances(PathsCell)
% PathsCell: 例如 Paths.Positive 或 Paths.Negative
% 计算每条等值线和其单方向
nCurves = numel(PathsCell);
minDistMat = inf(nCurves);

for i = 1:nCurves
    P1 = PathsCell{i};   % [x, y, z]
    for j = i+1:nCurves
        P2 = PathsCell{j};
        % 两条等值线所有点之间的欧氏距离
        D = pdist2(P1, P2); % 维度：len(P1) × len(P2)
        dmin = min(D(:));
        minDistMat(i,j) = dmin;
        minDistMat(j,i) = dmin;
    end
end

end

